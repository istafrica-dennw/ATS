name: Deploy ATS to AWS EC2

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: false
        type: boolean
  
  # Automatic trigger on push to main branch
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  
  # Trigger on pull request merge to main
  pull_request:
    branches: [ main ]
    types: [closed]

env:
  DEPLOYMENT_PATH: /home/ubuntu/ats-system
  NODE_VERSION: '18'
  JAVA_VERSION: '17'

jobs:
  # Job 1: Run tests (optional)
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('backend/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Run backend tests
        run: |
          cd backend
          ./mvnw test
      
      - name: Run frontend tests
        run: |
          cd frontend
          npm ci
          npm run test -- --coverage --watchAll=false
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            backend/target/surefire-reports/
            frontend/coverage/

  # Job 2: Build and deploy
  deploy:
    name: Deploy to AWS EC2
    runs-on: ubuntu-latest
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials (for future use)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
      
      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"
      
      - name: Check EC2 instance resources
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            echo "=== EC2 Instance Information ==="
            echo "Instance ID: $(curl -s http://169.254.169.254/latest/meta-data/instance-id)"
            echo "Instance Type: $(curl -s http://169.254.169.254/latest/meta-data/instance-type)"
            echo "Public IP: $(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)"
            echo "Available Memory: $(free -h | grep Mem | awk '{print $7}')"
            echo "Available Disk: $(df -h / | tail -1 | awk '{print $4}')"
            echo "Docker Status: $(systemctl is-active docker)"
            echo "==============================="
          EOF
      
      - name: Create deployment directory
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            sudo mkdir -p ${{ env.DEPLOYMENT_PATH }}
            sudo chown ubuntu:ubuntu ${{ env.DEPLOYMENT_PATH }}
          EOF
      
      - name: Stop existing application
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd ${{ env.DEPLOYMENT_PATH }}
            if [ -f docker-compose.aws.yml ]; then
              echo "Stopping existing application..."
              docker-compose -f docker-compose.aws.yml down || true
            fi
          EOF
      
      - name: Sync application files
        run: |
          # Use rsync to sync files efficiently
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='target' \
            --exclude='*.log' \
            --exclude='.env' \
            ./ ubuntu@${{ secrets.EC2_HOST }}:${{ env.DEPLOYMENT_PATH }}/
      
      - name: Create environment file
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd ${{ env.DEPLOYMENT_PATH }}
            
            # Create .env file with secrets
            cat > .env << 'ENVEOF'
            # Database Configuration
            POSTGRES_DB=ats_db
            POSTGRES_USER=ats_user
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/ats_db
            
            # Security Configuration
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            SPRING_SECURITY_USER_NAME=admin
            SPRING_SECURITY_USER_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
            SPRING_SECURITY_USER_ROLES=ADMIN
            
            # Email Configuration
            MAIL_HOST=smtp.gmail.com
            MAIL_PORT=587
            MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
            MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
            MAIL_FROM=${{ secrets.MAIL_FROM }}
            
            # OAuth Configuration
            LINKEDIN_CLIENT_ID=${{ secrets.LINKEDIN_CLIENT_ID }}
            LINKEDIN_CLIENT_SECRET=${{ secrets.LINKEDIN_CLIENT_SECRET }}
            
            # Gemini AI Configuration
            AI_PROVIDER=gemini
            AI_BASE_URL=https://generativelanguage.googleapis.com
            AI_MODEL=gemini-1.5-flash
            AI_API_KEY=${{ secrets.GEMINI_API_KEY }}
            AI_AUTH_TYPE=api-key
            AI_AUTH_HEADER=x-goog-api-key
            AI_REQUEST_FORMAT=gemini
            AI_GENERATION_ENDPOINT=/v1beta/models/gemini-1.5-flash:generateContent
            AI_HEALTH_ENDPOINT=/v1beta/models
            AI_RESPONSE_FIELD=candidates
            AI_MAX_TOKENS=1000
            AI_TEMPERATURE=0.1
            
            # Application Configuration
            REACT_APP_API_URL=http://${{ secrets.EC2_HOST }}:8080
            REACT_APP_SOCKET_URL=http://${{ secrets.EC2_HOST }}:9092
            UPLOADS_DIRECTORY=uploads
            ENVEOF
            
            chmod 600 .env
            echo "Environment file created successfully"
          EOF
      
      - name: Install dependencies and deploy
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd ${{ env.DEPLOYMENT_PATH }}
            
            # Make deploy script executable
            chmod +x deploy-aws.sh
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo apt update -y
              sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt update -y
              sudo apt install -y docker-ce docker-ce-cli containerd.io
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker ubuntu
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d'"' -f4)
              sudo curl -L "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi
            
            echo "Docker and Docker Compose are ready"
          EOF
      
      - name: Deploy application
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd ${{ env.DEPLOYMENT_PATH }}
            
            echo "Starting deployment..."
            
            # Clean up unused Docker resources
            docker system prune -f
            
            # Deploy with AWS-optimized configuration
            docker-compose -f docker-compose.aws.yml up -d --build
            
            echo "Deployment initiated. Waiting for services to be ready..."
            
            # Wait for services to be healthy
            timeout=300
            counter=0
            
            # Check PostgreSQL
            echo -n "Waiting for PostgreSQL: "
            while [ $counter -lt $timeout ]; do
              if docker exec ats-postgres-aws pg_isready -U ats_user -d ats_db 2>/dev/null; then
                echo " âœ“"
                break
              fi
              echo -n "."
              sleep 5
              counter=$((counter + 5))
            done
            
            # Check Backend
            echo -n "Waiting for Backend: "
            counter=0
            while [ $counter -lt $timeout ]; do
              if curl -s http://localhost:8080/actuator/health > /dev/null; then
                echo " âœ“"
                break
              fi
              echo -n "."
              sleep 5
              counter=$((counter + 5))
            done
            
            # Check Frontend
            echo -n "Waiting for Frontend: "
            counter=0
            while [ $counter -lt $timeout ]; do
              if curl -s http://localhost:3001 > /dev/null; then
                echo " âœ“"
                break
              fi
              echo -n "."
              sleep 5
              counter=$((counter + 5))
            done
            
            echo "All services are running!"
          EOF
      
      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            cd ${{ env.DEPLOYMENT_PATH }}
            
            echo "=== Deployment Verification ==="
            echo "Container Status:"
            docker-compose -f docker-compose.aws.yml ps
            
            echo ""
            echo "Memory Usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"
            
            echo ""
            echo "Health Checks:"
            echo -n "Backend Health: "
            curl -s http://localhost:8080/actuator/health | jq -r '.status' 2>/dev/null || echo "UNKNOWN"
            
            echo -n "Frontend Status: "
            curl -s -o /dev/null -w "%{http_code}" http://localhost:3001 || echo "UNKNOWN"
            
            echo ""
            echo "Application URLs:"
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            echo "Frontend: http://$PUBLIC_IP:3001"
            echo "Backend API: http://$PUBLIC_IP:8080"
            echo "API Documentation: http://$PUBLIC_IP:8080/swagger-ui.html"
            
            echo "==============================="
          EOF
      
      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment completed successfully!"
          else
            echo "âŒ Deployment failed. Check the logs above."
          fi
      
      - name: Post deployment summary
        if: success()
        run: |
          PUBLIC_IP=$(ssh -i ~/.ssh/id_rsa ubuntu@${{ secrets.EC2_HOST }} "curl -s http://169.254.169.254/latest/meta-data/public-ipv4" 2>/dev/null || echo "Unknown")
          
          echo "ðŸŽ‰ **Deployment Summary**" >> $GITHUB_STEP_SUMMARY
          echo "=========================" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Status**: Deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **Environment**: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ–¥ï¸  **Instance**: ${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Access URLs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: http://$PUBLIC_IP:3001" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API**: http://$PUBLIC_IP:8080" >> $GITHUB_STEP_SUMMARY
          echo "- **API Documentation**: http://$PUBLIC_IP:8080/swagger-ui.html" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”§ Management Commands:" >> $GITHUB_STEP_SUMMARY
          echo "```bash" >> $GITHUB_STEP_SUMMARY
          echo "# SSH to instance" >> $GITHUB_STEP_SUMMARY
          echo "ssh -i your-key.pem ubuntu@${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# View logs" >> $GITHUB_STEP_SUMMARY
          echo "docker-compose -f docker-compose.aws.yml logs -f" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check status" >> $GITHUB_STEP_SUMMARY
          echo "docker-compose -f docker-compose.aws.yml ps" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY 